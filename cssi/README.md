#################################################

C-CODE OF THE CSSI: CLASSICAL VERSION


	*) Meet in the middle attack:
		-) Naive approach (i.e., the basic version)
		-) Deph-First-Search (DFS) approach,
		-) Van Oorschot-Wiener approach.


Setting:

	-) p is a prime of the form 2^e_a*3^e_b*f - 1
	-) E is a supersingular curve, 
		E_A is 2^e_a-isogenous to E, and 
		E_A is 3^e_b-isogenous to E.
	-) P_A and Q_A are two oder-2^e_a points, and
		P_B and Q_B are two oder-3^e_b points,
		
Problem:

	-) We know \phi_A(P_B) and \phi_A(Q_B) in E_A, 
	-) We know \phi_B(P_A) and \phi_B(Q_A) in E_B, 
	-) We want to find an isogeny of degree:
		+) 2^e_a between E and E_A (\phi_A),
		+) 3^e_b between E and E_B (\phi_B).
		
	-) We have two order-2^e_a points S_A and T_A 
		in E_A, and two order-3^e_b points S_B and 
		T_B in E_B.
	
	-) This attack finds two isomorphic curves
		C_0 and C_1 with kernels generated by:
		+) [2^{e_a/2}](P_A + m_a * Q_A), and 
			[2^{e_a/2}](S_A + k_a * T_A) (or 
			[2^{e_a/2}](l_a * S_A + T_A) ).
			Or
		+) [3^{e_b/2}](P_B + m_b * Q_B), and 
			[3^{e_b/2}](S_B + k_b * T_B) (or 
			[3^{e_b/2}](l_b * S_B + T_B) ).
			
	-) In addition, we find the kernel of \phi_A 
	(or \phi_B) by connecting the curves C0 and C_1 
	to obtain an 2^e_a-isogeny (or 3^e_b-isogeny),
	i.e., we send P_A and Q_A (or P_B and Q_B) into
	the new curve determined by C_0 and C_1, and 
	then we solve a DLP.
		
#################################################

# Created by:	Jesús Javier Chi Domínguez 
               <chidoys@gmail.com>,
               <jjchi@computacion.cs.cinvestav.mx>

# Thanks to José Eduardo Ochoa Jiménez for 
  its modular arithmetic implementation.
 
# The elliptic curve arithmetic was obtained from 
  the formulaes that 
  Daniel J. Bernstein and Tanja Lange
  have in their website:
  https://www.hyperelliptic.org/EFD/oldefd/jacobian.html

#################################################

#-----------------------------------------------#

Getting Started:

These instructions will get you a copy of the 
project up and running on your local machine 
for development and testing purposes. 

#-----------------------------------------------#

Prerequisites:
Any version of gcc, and openmpe library must be 
installed.

#-----------------------------------------------#

Installing:
You need to configure the headers:
	- setup_FF.h, and
	- setup_EC.h
and the assambly file Arith.S.

You can do such configuration by running the
following statement:

	sh cofing.sh

---

Moreover, if you want to change the prime p you
should modify the file:

	./magma/ea.eb.f

The format of ea.eb.f should be as follows:

	var_A := 32;
	var_B := 20;
	var_f := 23;

---

You need to build the executables by running the
following statement:

	sh build.sh

Now, you're able for ATTACKS instances!

#-----------------------------------------------#

Running the tests:

NAIVE APPROACH:
	./bin/naive NUMBER_OF_CORES ALICE_OR_BOB

DFS APPROACH:
	./bin/dfs NUMBER_OF_CORES ALICE_OR_BOB
		
LAMBDA APPROACH:
	./bin/lambda NUMBER_OF_CORES ALICE_OR_BOB W BETA NUMBER_OF_FUNCTIONS_TO_USED

Here, ALICE_OR_BOB can take the values A or B (but the case B is 
not implemented). In addition, the input NUMBER_OF_FUNCTIONS_TO_USED, 
is an optional input that determines how many different versions 
of the function f you want to reached (only for estimations).

For making several experiments, you can run

	sh run_naive NUMBER_OF_CORES NUMBER_OF_EXPERIMENTS
To check the median and mean of the experiments, you can run:
	python naive_results.py
Output:
	- Measured running time,
	- Measured Clock Cycles,
		
	sh run_dfs NUMBER_OF_CORES NUMBER_OF_EXPERIMENTS
To check the median and mean of the experiments, you can run:
	python dfs_results.py
Output:
	- Measured running time,
	- Measured Clock Cycles,
	
	sh run_lambda NUMBER_OF_CORES W BETA NUMBER_OF_EXPERIMENTS NUMBER_OF_FUNCTIONS_TO_USED
To check the median and mean of the experiments, you can run:
	python lambda_results.py
Output:
	- Measured running time,
	- Measured running time for all dist. points reached,
	- Measured running time for all collisions reached,
	- Number of functions,
	- Measured Clock Cycles,
	- Distinguished points reached,
	- Different distinguished points reached,
	- Different collisions reached, and
	- Total collisions reached.

