#################################################


This research project was realized by:

*) Adj Gora,

*) Cervantes-Vázquez Daniel,

*) Chi-Domínguez Jesús-Javier

*) Menezes Alfred, and

*) Rodríguez-Henríquez Francisco



C-CODE OF THE CSSI: CLASSICAL VERSION


	*) Meet in the middle attack:
		-) Naive approach (i.e., the basic version)
		-) Deph-First-Search (DFS) approach,
		-) Van Oorschot-Wiener approach.


Setting:

	-) p is a prime of the form 2^e_a*3^e_b*f - 1
	-) E is a supersingular curve, 
		E_A is 2^e_a-isogenous to E, and 
		E_A is 3^e_b-isogenous to E.
	-) P_A and Q_A are two oder-2^e_a points, and
		P_B and Q_B are two oder-3^e_b points,
		
Problem:

	-) We know \phi_A(P_B) and \phi_A(Q_B) in E_A, 
	-) We know \phi_B(P_A) and \phi_B(Q_A) in E_B, 
	-) We want to find an isogeny of degree:
		+) 2^e_a between E and E_A (\phi_A),
		+) 3^e_b between E and E_B (\phi_B).
		
	-) We have two order-2^e_a points S_A and T_A 
		in E_A, and two order-3^e_b points S_B and 
		T_B in E_B.
	
	-) This attack finds two isomorphic curves
		C_0 and C_1 with kernels generated by:
		+) [2^{e_a/2}](P_A + m_a * Q_A), and 
			[2^{e_a/2}](S_A + k_a * T_A) (or 
			[2^{e_a/2}](l_a * S_A + T_A) ).
			Or
		+) [3^{e_b/2}](P_B + m_b * Q_B), and 
			[3^{e_b/2}](S_B + k_b * T_B) (or 
			[3^{e_b/2}](l_b * S_B + T_B) ).
			
	-) In addition, we find the kernel of \phi_A 
	(or \phi_B) by connecting the curves C0 and C_1 
	to obtain an 2^e_a-isogeny (or 3^e_b-isogeny),
	i.e., we send P_A and Q_A (or P_B and Q_B) into
	the new curve determined by C_0 and C_1, and 
	then we solve a DLP.
		
#################################################

  This code was created by:	Jesús Javier Chi Domínguez 
               <chidoys@gmail.com>,
               <jjchi@computacion.cs.cinvestav.mx>

  Thanks to José Eduardo Ochoa Jiménez for 
  its modular arithmetic implementation.
 
  The elliptic curve arithmetic was obtained from 
  the formulaes that 
  Daniel J. Bernstein and Tanja Lange
  have in their website:
  https://www.hyperelliptic.org/EFD/oldefd/jacobian.html

#################################################

#-----------------------------------------------#

Getting Started:

These instructions will get you a copy of the 
project up and running on your local machine 
for development and testing purposes. 

#-----------------------------------------------#

Prerequisites:
Any version of gcc, and openmp library must be 
installed.

#-----------------------------------------------#

Installing:
You need to configure the headers:
	- setup_FF.h, and
	- setup_EC.h
and the assambly file Arith.S.

You can do such configuration by running the
following statement (you need to have install magma):

	sh cofing.sh

---

Moreover, if you want to change the prime p you
should modify the file:

	./magma/ea.eb.f

The format of ea.eb.f should be as follows:

	var_A := 32;
	var_B := 20;
	var_f := 23;

---

You need to build the executables by running the
following statement:

	sh build.sh

Now, you're able for ATTACKS instances!

#-----------------------------------------------#

Running the tests:

NAIVE APPROACH:

	./bin/naive NUMBER_OF_CORES ALICE_OR_BOB

DFS APPROACH:

	./bin/dfs NUMBER_OF_CORES ALICE_OR_BOB
		
LAMBDA APPROACH:

	./bin/lambda NUMBER_OF_CORES ALICE_OR_BOB W BETA NUMBER_OF_FUNCTIONS_TO_USED

Here, ALICE_OR_BOB can take the values A or B (but the case B is 
not implemented). In addition, the input NUMBER_OF_FUNCTIONS_TO_USED, 
is an optional input that determines how many different versions 
of the function f you want to reached (only for estimations).

For making several experiments, you can run

	sh run_naive NUMBER_OF_CORES NUMBER_OF_EXPERIMENTS
	
To check the median and mean of the experiments, you can run:

	python naive_results.py
Output:

	- Measured running time,
	
	- Measured Clock Cycles,
		
	sh run_dfs NUMBER_OF_CORES NUMBER_OF_EXPERIMENTS
To check the median and mean of the experiments, you can run:
	python dfs_results.py
Output:
	- Measured running time,
	- Measured Clock Cycles,
	
	sh run_lambda NUMBER_OF_CORES W BETA NUMBER_OF_EXPERIMENTS NUMBER_OF_FUNCTIONS_TO_USED
To check the median and mean of the experiments, you can run:
	python lambda_results.py
Output:

	- Measured running time,
	
	- Measured running time for all dist. points reached,
	
	- Measured running time for all collisions reached,
	
	- Number of functions,
	
	- Measured Clock Cycles,
	
	- Distinguished points reached,
	
	- Different distinguished points reached,
	
	- Different collisions reached, and
	
	- Total collisions reached.

